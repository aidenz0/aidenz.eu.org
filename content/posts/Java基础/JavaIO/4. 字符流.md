+++
date = '2025-10-26'
draft = true
title = '字符流'
+++

# 字符流
**字符流 = 字节流 + 编码表**
## 字符输入流
`java.io.Reader`是**字符输入流**的**超类**（父类），它定义了字符输入流的一些共性方法：

- 1、`close()`：关闭此流并释放与此流相关的系统资源。
- 2、`read()`：从输入流读取一个字符。
- 3、`read(char[] cbuf)`：从输入流中读取一些字符，并将它们存储到字符数组 `cbuf`中

FileReader 是 Reader 的子类，用于从文件中读取字符数据。它的主要特点如下：

- 可以通过构造方法指定要读取的文件路径。
- 每次可以读取一个或多个字符。
- 可以读取 Unicode 字符集中的字符，通过指定字符编码来实现字符集的转换
### FileReader构造方法
- 1、`FileReader(File file)`：创建一个新的 FileReader，参数为**File对象**。
- 2、`FileReader(String fileName)`：创建一个新的 FileReader，参数为文件名。
### FileReader读取字符数据
**读取字符**：`read`方法，每次可以读取一个字符，返回读取的字符（转为 int 类型），当读取到文件末尾时，返回`-1`。代码示例如下：
**读取指定长度的字符**：`read(char[] cbuf, int off, int len)`，并将其存储到字符数组中。其中，cbuf 表示存储读取结果的字符数组，off 表示存储结果的起始位置，len 表示要读取的字符数。代码示例如下：
## 字符输出流
`java.io.Writer` 是**字符输出流**类的**超类**（父类），可以将指定的字符信息写入到目的地，来看它定义的一些共性方法：

- 1、`write(int c)` 写入单个字符。
- 2、`write(char[] cbuf)` 写入字符数组。
- 3、`write(char[] cbuf, int off, int len)` 写入字符数组的一部分，off为开始索引，len为字符个数。
- 4、`write(String str)` 写入字符串。
- 5、`write(String str, int off, int len)` 写入字符串的某一部分，off 指定要写入的子串在 str 中的起始位置，len 指定要写入的子串的长度。
- 6、`flush()` 刷新该流的缓冲。
- 7、`close()` 关闭此流，但要先刷新它。

`java.io.FileWriter` 类是 Writer 的子类，用来将字符写入到文件
### FileReader构造方法
- `FileWriter(File file)`： 创建一个新的 FileWriter，参数为要读取的File对象。
- `FileWriter(String fileName)`： 创建一个新的 FileWriter，参数为要读取的文件的名称。
### FileReader写入数据
写入字符数组
```java
FileWriter fw = null;
try {
    fw = new FileWriter("output.txt");
    char[] chars = {'H', 'e', 'l', 'l', 'o'};
    fw.write(chars); // 将字符数组写入文件
} catch (IOException e) {
    e.printStackTrace();
} finally {
    try {
        if (fw != null) {
            fw.close();
        }
    } catch (IOException e) {
        e.printStackTrace();
    }
}
```
**写入指定字符数组**：`write(char[] cbuf, int off, int len)` 方法:
```java
fw = new FileWriter("output.txt");
    char[] chars = {'H', 'e', 'l', 'l', 'o', ',', ' ', 'W', 'o', 'r', 'l', 'd', '!'};
fw.write(chars, 0, 5); // 将字符数组的前 5 个字符写入文件
```
**写入字符串**：`write(String str)` 方法，将指定字符串写入输出流。
```java
fw = new FileWriter("output.txt");
String str = "沉默王二";
fw.write(str); // 将字符串写入文件
```
**写入指定字符串**：`write(String str, int off, int len)` 方法，将指定字符串的一部分写入输出流。
```java
String str = "沉默王二真的帅啊！";
try (FileWriter fw = new FileWriter("output.txt")) {
    fw.write(str, 0, 5); // 将字符串的前 5 个字符写入文件
} catch (IOException e) {
    e.printStackTrace();
}
```
### 关闭close和刷新flush
因为 FileWriter 内置了缓冲区 ByteBuffer，所以如果不关闭输出流，就无法把字符写入到文件中。
但是关闭了流对象，就无法继续写数据了。如果我们既想写入数据，又想继续使用流，就需要 `flush` 方法了。

`flush` ：刷新缓冲区，流对象可以继续使用。

`close` ：先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。
### FileReader续写和换行
```java
// 使用文件名称创建流对象，可以续写数据
FileWriter fw = new FileWriter("fw.txt",true);     
// 写出字符串
fw.write("沉默王二");
// 写出换行
fw.write("\r\n");
// 写出字符串
fw.write("是傻 X");
// 关闭资源
fw.close();
```
### 文件复制
```java
package IO.io_first;  
  
import java.io.*;  
  
public class FileReaderWriterDemo {  
    public static void main(String[] args) {  
        File file = new File("d:\\Users\\Administrator\\Downloads\\example.txt");  
        File fileCp1 = new File("D:\\Users\\Administrator\\Downloads\\example_cp1.txt");  
        File fileCp2 = new File("D:\\Users\\Administrator\\Downloads\\example_cp2.txt");  
        try {  
            FileReader fr1 = new FileReader(file);  
            FileReader fr2 = new FileReader(file);  
            FileWriter fw1 = new FileWriter(fileCp1);  
            FileWriter fw2 = new FileWriter(fileCp2);  
            cp1(fr1, fw1);  
            fw1.close();  
            cp2(fr2, fw2);  
            fw2.close();  
            fr1.close();  
            fr2.close();  
        } catch (IOException e) {  
            throw new RuntimeException(e);  
        }  
    }  
  
    public static void cp1(FileReader fr, FileWriter fw ) throws IOException {  
        int b;  
        while((b = fr.read())!=-1){  
            fw.write(b);  
        }  
//        fw.flush();  
    }  
  
    public static void cp2(FileReader fr, FileWriter fw ) throws IOException {  
        char cbuf[] = new char[1024];  
        int len;  
        while((len = fr.read(cbuf)) != -1){  
            fw.write(cbuf,0,len);  
        }  
//        fw.flush();  
    }  
}
```